# æµ‹è¯•ä¸è´¨é‡ä¿éšœ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰äº†å•å…ƒæµ‹è¯•æ¨¡æ¿ã€æ€§èƒ½ç›‘æ§æ‰“ç‚¹è¦æ±‚ã€ä»£ç è´¨é‡æ£€æŸ¥æ ‡å‡†å’Œæµ‹è¯•æœ€ä½³å®è·µã€‚

## ğŸ§ª å•å…ƒæµ‹è¯•

### 1. ViewModel æµ‹è¯•

#### æµ‹è¯•æ¨¡æ¿
```kotlin
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever

@OptIn(ExperimentalCoroutinesApi::class)
class UserViewModelTest {
    
    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    private lateinit var viewModel: UserViewModel
    private lateinit var userApi: UserApi
    
    @Before
    fun setup() {
        userApi = mock()
        viewModel = UserViewModel(userApi)
    }
    
    @Test
    fun `loadUsers should emit Success state when API returns data`() = runTest {
        // Given
        val users = listOf(
            User("1", "å¼ ä¸‰", "zhangsan@example.com"),
            User("2", "æå››", "lisi@example.com")
        )
        whenever(userApi.getUserList()).thenReturn(
            ApiResponse(200, "success", users)
        )
        
        // When
        viewModel.sendIntent(UserIntent.LoadUsers)
        advanceUntilIdle()
        
        // Then
        val state = viewModel.userState.value
        assert(state is UiState.Success)
        assert((state as UiState.Success).data == users)
    }
    
    @Test
    fun `loadUsers should emit Error state when API fails`() = runTest {
        // Given
        whenever(userApi.getUserList()).thenThrow(IOException("Network error"))
        
        // When
        viewModel.sendIntent(UserIntent.LoadUsers)
        advanceUntilIdle()
        
        // Then
        val state = viewModel.userState.value
        assert(state is UiState.Error)
        assert((state as UiState.Error).message.contains("Network error"))
    }
    
    @Test
    fun `deleteUser should show toast and reload users`() = runTest {
        // Given
        val userId = "1"
        whenever(userApi.deleteUser(userId)).thenReturn(
            ApiResponse(200, "åˆ é™¤æˆåŠŸ", true)
        )
        whenever(userApi.getUserList()).thenReturn(
            ApiResponse(200, "success", emptyList())
        )
        
        // When
        viewModel.sendIntent(UserIntent.DeleteUser(userId))
        advanceUntilIdle()
        
        // Then
        // éªŒè¯ Toast äº‹ä»¶
        // éªŒè¯é‡æ–°åŠ è½½
    }
}
```

#### æµ‹è¯•è§„åˆ™
```kotlin
/**
 * Main Dispatcher Rule for testing
 */
@OptIn(ExperimentalCoroutinesApi::class)
class MainDispatcherRule(
    private val testDispatcher: TestDispatcher = StandardTestDispatcher()
) : TestWatcher() {
    
    override fun starting(description: Description) {
        Dispatchers.setMain(testDispatcher)
    }
    
    override fun finished(description: Description) {
        Dispatchers.resetMain()
    }
}
```

### 2. Repository æµ‹è¯•

#### æµ‹è¯•æ¨¡æ¿
```kotlin
class UserRepositoryTest {
    
    private lateinit var repository: UserRepository
    private lateinit var userApi: UserApi
    private lateinit var userDao: UserDao
    
    @Before
    fun setup() {
        userApi = mock()
        userDao = mock()
        repository = UserRepository(userApi, userDao)
    }
    
    @Test
    fun `getUsers should return cached data when available`() = runTest {
        // Given
        val cachedUsers = listOf(User("1", "å¼ ä¸‰", "zhangsan@example.com"))
        whenever(userDao.getAllUsers()).thenReturn(cachedUsers)
        
        // When
        val result = repository.getUsers()
        
        // Then
        assert(result == cachedUsers)
    }
    
    @Test
    fun `getUsers should fetch from API and cache when cache is empty`() = runTest {
        // Given
        val apiUsers = listOf(User("1", "å¼ ä¸‰", "zhangsan@example.com"))
        whenever(userDao.getAllUsers()).thenReturn(emptyList())
        whenever(userApi.getUserList()).thenReturn(
            ApiResponse(200, "success", apiUsers)
        )
        
        // When
        val result = repository.getUsers()
        
        // Then
        assert(result == apiUsers)
        verify(userDao).insertUsers(apiUsers)
    }
}
```

### 3. å·¥å…·ç±»æµ‹è¯•

#### æµ‹è¯•æ¨¡æ¿
```kotlin
class StringUtilsTest {
    
    @Test
    fun `validateEmail should return true for valid email`() {
        // Given
        val email = "test@example.com"
        
        // When
        val result = StringUtils.validateEmail(email)
        
        // Then
        assert(result == true)
    }
    
    @Test
    fun `validateEmail should return false for invalid email`() {
        // Given
        val email = "invalid-email"
        
        // When
        val result = StringUtils.validateEmail(email)
        
        // Then
        assert(result == false)
    }
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§

### 1. ç½‘ç»œè¯·æ±‚ç›‘æ§

#### è¯·æ±‚æ—¶é—´æ‰“ç‚¹
```kotlin
class NetworkMonitorInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val startTime = System.currentTimeMillis()
        
        val response = chain.proceed(request)
        
        val duration = System.currentTimeMillis() - startTime
        
        // âœ… è®°å½•è¯·æ±‚æ—¶é—´
        Log.d("Network", "Request: ${request.url} took ${duration}ms")
        
        // âœ… æ€§èƒ½ç›‘æ§æ‰“ç‚¹
        PerformanceMonitor.recordNetworkRequest(
            url = request.url.toString(),
            method = request.method,
            duration = duration,
            statusCode = response.code
        )
        
        return response
    }
}
```

#### æ€§èƒ½ç›‘æ§å·¥å…·ç±»
```kotlin
object PerformanceMonitor {
    
    /**
     * è®°å½•ç½‘ç»œè¯·æ±‚æ€§èƒ½
     */
    fun recordNetworkRequest(
        url: String,
        method: String,
        duration: Long,
        statusCode: Int
    ) {
        // è®°å½•åˆ°æœ¬åœ°æˆ–ä¸ŠæŠ¥åˆ°æœåŠ¡å™¨
        val metric = NetworkMetric(
            url = url,
            method = method,
            duration = duration,
            statusCode = statusCode,
            timestamp = System.currentTimeMillis()
        )
        
        // ä¿å­˜åˆ°æœ¬åœ°æ•°æ®åº“æˆ–ä¸ŠæŠ¥
        saveMetric(metric)
    }
    
    /**
     * è®°å½•é¡µé¢åŠ è½½æ—¶é—´
     */
    fun recordPageLoadTime(pageName: String, loadTime: Long) {
        val metric = PageLoadMetric(
            pageName = pageName,
            loadTime = loadTime,
            timestamp = System.currentTimeMillis()
        )
        saveMetric(metric)
    }
    
    /**
     * è®°å½•å†…å­˜ä½¿ç”¨
     */
    fun recordMemoryUsage() {
        val runtime = Runtime.getRuntime()
        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024
        val maxMemory = runtime.maxMemory() / 1024 / 1024
        
        val metric = MemoryMetric(
            usedMemory = usedMemory,
            maxMemory = maxMemory,
            timestamp = System.currentTimeMillis()
        )
        saveMetric(metric)
    }
}
```

### 2. é¡µé¢æ€§èƒ½ç›‘æ§

#### Activity ç”Ÿå‘½å‘¨æœŸç›‘æ§
```kotlin
abstract class MviActivity<VB : ViewBinding, VM : MviViewModel<I>, I : MviIntent> :
    AppCompatActivity() {
    
    private var onCreateTime: Long = 0
    private var onStartTime: Long = 0
    
    override fun onCreate(savedInstanceState: Bundle?) {
        onCreateTime = System.currentTimeMillis()
        super.onCreate(savedInstanceState)
        // ...
    }
    
    override fun onStart() {
        super.onStart()
        onStartTime = System.currentTimeMillis()
        
        val loadTime = onStartTime - onCreateTime
        PerformanceMonitor.recordPageLoadTime(
            pageName = this::class.java.simpleName,
            loadTime = loadTime
        )
    }
}
```

### 3. å†…å­˜ç›‘æ§

#### å†…å­˜æ³„æ¼æ£€æµ‹
```kotlin
// âœ… åœ¨ Application ä¸­åˆå§‹åŒ–å†…å­˜ç›‘æ§
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        
        if (BuildConfig.DEBUG) {
            // ä½¿ç”¨ LeakCanary æ£€æµ‹å†…å­˜æ³„æ¼
            // LeakCanary ä¼šè‡ªåŠ¨æ£€æµ‹ Activityã€Fragment ç­‰çš„å†…å­˜æ³„æ¼
        }
    }
}
```

#### å†…å­˜ä½¿ç”¨ç›‘æ§
```kotlin
class MemoryMonitor {
    
    /**
     * è·å–å½“å‰å†…å­˜ä½¿ç”¨æƒ…å†µ
     */
    fun getMemoryInfo(): MemoryInfo {
        val runtime = Runtime.getRuntime()
        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024
        val maxMemory = runtime.maxMemory() / 1024 / 1024
        val freeMemory = runtime.freeMemory() / 1024 / 1024
        
        return MemoryInfo(
            usedMemory = usedMemory,
            maxMemory = maxMemory,
            freeMemory = freeMemory
        )
    }
    
    /**
     * æ£€æŸ¥å†…å­˜ä½¿ç”¨æ˜¯å¦è¿‡é«˜
     */
    fun isMemoryHigh(): Boolean {
        val info = getMemoryInfo()
        val usagePercent = (info.usedMemory.toFloat() / info.maxMemory.toFloat()) * 100
        return usagePercent > 80  // ä½¿ç”¨ç‡è¶…è¿‡ 80% è®¤ä¸ºè¿‡é«˜
    }
}
```

## ğŸ” ä»£ç è´¨é‡æ£€æŸ¥

### 1. Lint é…ç½®

#### lint.xml é…ç½®
```xml
<?xml version="1.0" encoding="UTF-8"?>
<lint>
    <!-- ç¦æ­¢ç¡¬ç¼–ç å­—ç¬¦ä¸² -->
    <issue id="HardcodedText" severity="error" />
    
    <!-- ç¦æ­¢ä½¿ç”¨ findViewById -->
    <issue id="ViewHolder" severity="warning" />
    
    <!-- æ£€æŸ¥æœªä½¿ç”¨çš„èµ„æº -->
    <issue id="UnusedResources" severity="warning" />
    
    <!-- æ£€æŸ¥å†…å­˜æ³„æ¼ -->
    <issue id="HandlerLeak" severity="error" />
    
    <!-- æ£€æŸ¥æƒé™ä½¿ç”¨ -->
    <issue id="MissingPermission" severity="error" />
</lint>
```

### 2. ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•

#### ViewModel æ£€æŸ¥
- [ ] æ˜¯å¦ä½¿ç”¨ `viewModelScope` ç®¡ç†åç¨‹ï¼Ÿ
- [ ] æ˜¯å¦ä½¿ç”¨ `StateFlow` ç®¡ç†çŠ¶æ€ï¼Ÿ
- [ ] æ˜¯å¦åŒ…å«é”™è¯¯å¤„ç†ï¼Ÿ
- [ ] æ˜¯å¦ä½¿ç”¨ `launchRequest` å¤„ç†ç½‘ç»œè¯·æ±‚ï¼Ÿ

#### Activity/Fragment æ£€æŸ¥
- [ ] æ˜¯å¦ä½¿ç”¨ `repeatOnLifecycle` æ”¶é›† Flowï¼Ÿ
- [ ] æ˜¯å¦ä½¿ç”¨ ViewBindingï¼Ÿ
- [ ] æ˜¯å¦åœ¨ `onDestroy` ä¸­æ¸…ç†èµ„æºï¼Ÿ

#### ç½‘ç»œè¯·æ±‚æ£€æŸ¥
- [ ] æ˜¯å¦ä½¿ç”¨ HTTPSï¼Ÿ
- [ ] æ˜¯å¦åŒ…å«é”™è¯¯å¤„ç†ï¼Ÿ
- [ ] æ˜¯å¦è®°å½•è¯·æ±‚æ—¥å¿—ï¼Ÿ

## ğŸ“ æµ‹è¯•æœ€ä½³å®è·µ

### 1. æµ‹è¯•è¦†ç›–ç‡

#### ç›®æ ‡è¦†ç›–ç‡
- **ViewModel**: â‰¥ 80%
- **Repository**: â‰¥ 80%
- **å·¥å…·ç±»**: â‰¥ 90%

#### è¦†ç›–ç‡æ£€æŸ¥
```gradle
// build.gradle
android {
    testOptions {
        unitTests {
            includeAndroidResources = true
        }
    }
}

// ä½¿ç”¨ JaCoCo ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.8.7"
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
}
```

### 2. æµ‹è¯•å‘½åè§„èŒƒ

#### å‘½åæ ¼å¼
```kotlin
// âœ… æ­£ç¡®ï¼šä½¿ç”¨æè¿°æ€§åç§°
@Test
fun `loadUsers should emit Success state when API returns data`() { }

@Test
fun `deleteUser should show toast and reload users`() { }

// âŒ é”™è¯¯ï¼šä½¿ç”¨ç®€çŸ­åç§°
@Test
fun testLoadUsers() { }  // âŒ ä¸å¤Ÿæè¿°æ€§
```

### 3. æµ‹è¯•æ•°æ®

#### Mock æ•°æ®
```kotlin
object TestData {
    val mockUsers = listOf(
        User("1", "å¼ ä¸‰", "zhangsan@example.com"),
        User("2", "æå››", "lisi@example.com"),
        User("3", "ç‹äº”", "wangwu@example.com")
    )
    
    val mockUser = User("1", "å¼ ä¸‰", "zhangsan@example.com")
    
    val mockApiResponse = ApiResponse(
        code = 200,
        message = "success",
        data = mockUsers
    )
}
```

## ğŸš« ç¦æ­¢äº‹é¡¹

### 1. æµ‹è¯•è¿è§„
```kotlin
// âŒ é”™è¯¯ï¼šæµ‹è¯•ä¸­ä½¿ç”¨çœŸå®ç½‘ç»œè¯·æ±‚
@Test
fun loadUsers() {
    val viewModel = UserViewModel(realApi)  // âŒ åº”è¯¥ä½¿ç”¨ Mock
    viewModel.sendIntent(UserIntent.LoadUsers)
}

// âŒ é”™è¯¯ï¼šæµ‹è¯•ä¸­ä½¿ç”¨çœŸå®æ•°æ®åº“
@Test
fun getUsers() {
    val repository = UserRepository(realApi, realDao)  // âŒ åº”è¯¥ä½¿ç”¨ Mock
}
```

### 2. æ€§èƒ½ç›‘æ§è¿è§„
```kotlin
// âŒ é”™è¯¯ï¼šåœ¨ç”Ÿäº§ç¯å¢ƒè®°å½•æ•æ„Ÿä¿¡æ¯
PerformanceMonitor.recordNetworkRequest(
    url = request.url.toString(),
    headers = request.headers  // âŒ åŒ…å« Token ç­‰æ•æ„Ÿä¿¡æ¯
)
```

---

**æœ€åæ›´æ–°**: 2024-12-17  
**ç»´æŠ¤è€…**: aFramework Team
